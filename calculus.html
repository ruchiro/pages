<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculus in the Real World</title>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-deep: #0a0a0f;
            --bg-card: #12121a;
            --accent-warm: #ff6b35;
            --accent-cool: #4ecdc4;
            --accent-gold: #ffd700;
            --text-primary: #f5f5f0;
            --text-muted: #8a8a95;
            --border-subtle: rgba(255,255,255,0.08);
        }

        body {
            font-family: 'Cormorant Garamond', Georgia, serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Grain overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        header {
            text-align: center;
            padding: 80px 20px 60px;
            position: relative;
        }

        header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-warm), transparent);
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 4.5rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-warm) 50%, var(--accent-cool) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.3rem;
            color: var(--text-muted);
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .scenarios {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px 100px;
        }

        .scenario {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 24px;
            margin-bottom: 60px;
            overflow: hidden;
            position: relative;
        }

        .scenario::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-warm), var(--accent-cool));
        }

        .scenario-header {
            padding: 40px 50px 30px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .scenario-number {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-warm);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        .scenario-title {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .scenario-question {
            font-size: 1.1rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .scenario-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
        }

        @media (max-width: 900px) {
            .scenario-content {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile-specific styles */
        @media (max-width: 600px) {
            header {
                padding: 50px 15px 40px;
            }

            .subtitle {
                font-size: 1.1rem;
                padding: 0 10px;
            }

            .scenarios {
                padding: 20px 12px 60px;
            }

            .scenario {
                border-radius: 16px;
                margin-bottom: 40px;
            }

            .scenario-header {
                padding: 25px 20px 20px;
            }

            .scenario-title {
                font-size: 1.5rem;
            }

            .scenario-question {
                font-size: 1rem;
            }

            .visualization {
                padding: 20px 15px;
                min-height: auto;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }

            .legend {
                flex-wrap: wrap;
                gap: 10px 15px;
                font-size: 0.65rem;
                justify-content: center;
            }

            .explanation {
                padding: 25px 20px;
            }

            .math-box {
                padding: 15px 18px;
                margin: 15px 0;
                overflow-x: auto;
            }

            .math-box h4 {
                font-size: 0.65rem;
            }

            .formula {
                font-size: 0.95rem;
                line-height: 2;
            }

            .formula .katex {
                font-size: 1em;
            }

            .formula .equation-row {
                overflow-x: auto;
                padding-bottom: 5px;
            }

            .insight {
                font-size: 1.05rem;
                line-height: 1.7;
            }

            .controls {
                flex-direction: column;
                gap: 20px;
            }

            .slider-group {
                min-width: 100%;
            }

            .slider-group label {
                font-size: 0.65rem;
            }

            input[type="range"] {
                height: 8px;
            }

            input[type="range"]::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            .value-display {
                font-size: 0.8rem;
            }

            button {
                width: 100%;
                padding: 14px 28px;
            }

            footer {
                padding: 40px 20px;
                font-size: 0.95rem;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            input[type="range"]::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }

            input[type="range"] {
                height: 10px;
            }

            button {
                padding: 16px 28px;
                font-size: 1.1rem;
            }
        }

        .visualization {
            padding: 40px;
            background: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }

        canvas {
            border-radius: 12px;
            background: rgba(0,0,0,0.4);
        }

        .explanation {
            padding: 40px 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .math-box {
            background: rgba(255,107,53,0.08);
            border-left: 3px solid var(--accent-warm);
            padding: 20px 25px;
            margin: 20px 0;
            border-radius: 0 12px 12px 0;
        }

        .math-box h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-warm);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        .formula {
            font-size: 1.1rem;
            color: var(--text-primary);
            line-height: 2.2;
        }

        .formula .katex {
            font-size: 1.15em;
        }

        .formula .equation-row {
            display: block;
            margin: 8px 0;
        }

        .formula .equation-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-right: 10px;
        }

        .insight {
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--text-muted);
        }

        .insight strong {
            color: var(--accent-cool);
            font-weight: 600;
        }

        .insight em {
            color: var(--accent-warm);
            font-style: normal;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .slider-group {
            flex: 1;
            min-width: 200px;
        }

        .slider-group label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--border-subtle);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-warm);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-cool);
            margin-top: 5px;
        }

        button {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1rem;
            padding: 12px 28px;
            background: transparent;
            border: 1px solid var(--accent-warm);
            color: var(--accent-warm);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: var(--accent-warm);
            color: var(--bg-deep);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .scenario {
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .scenario:nth-child(1) { animation-delay: 0.1s; }
        .scenario:nth-child(2) { animation-delay: 0.2s; }
        .scenario:nth-child(3) { animation-delay: 0.3s; }
        .scenario:nth-child(4) { animation-delay: 0.4s; }

        footer {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
            font-size: 1rem;
            border-top: 1px solid var(--border-subtle);
        }

        footer em {
            color: var(--accent-warm);
            font-style: normal;
        }
    </style>
</head>
<body>
    <header>
        <h1>Calculus Unveiled</h1>
        <p class="subtitle">Four scenarios that reveal how derivatives and integrals describe the hidden mechanics of our world</p>
    </header>

    <main class="scenarios">
        <!-- Scenario 1: Falling Coffee -->
        <section class="scenario">
            <div class="scenario-header">
                <div class="scenario-number">Scenario 01</div>
                <h2 class="scenario-title">The Cooling Coffee</h2>
                <p class="scenario-question">How does a hot cup of coffee cool down over time?</p>
            </div>
            <div class="scenario-content">
                <div class="visualization">
                    <canvas id="coffeeCanvas" width="450" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b35;"></div>
                            <span>Temperature T(t)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>Cooling Rate dT/dt</span>
                        </div>
                    </div>
                </div>
                <div class="explanation">
                    <div class="math-box">
                        <h4>Newton's Law of Cooling</h4>
                        <div class="formula">
                            <span class="equation-row" id="eq1a"></span>
                            <span class="equation-row" id="eq1b"></span>
                        </div>
                    </div>
                    <p class="insight">
                        The derivative <strong>dT/dt</strong> tells us the <em>rate of cooling</em> at any instant. Notice how <strong>the rate is proportional to the temperature difference</strong>—hot coffee cools fast, but as it approaches room temperature, cooling slows dramatically. The integral of this rate gives us the temperature curve itself.
                    </p>
                    <div class="controls">
                        <div class="slider-group">
                            <label>Cooling Constant (k)</label>
                            <input type="range" id="coffeeK" min="0.01" max="0.15" step="0.01" value="0.05">
                            <div class="value-display" id="coffeeKValue">k = 0.05</div>
                        </div>
                        <div class="slider-group">
                            <label>Initial Temp (°C)</label>
                            <input type="range" id="coffeeT0" min="60" max="100" step="5" value="90">
                            <div class="value-display" id="coffeeT0Value">T₀ = 90°C</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Scenario 2: Spreading Disease -->
        <section class="scenario">
            <div class="scenario-header">
                <div class="scenario-number">Scenario 02</div>
                <h2 class="scenario-title">The Spreading Epidemic</h2>
                <p class="scenario-question">Why do diseases spread slowly at first, explode, then taper off?</p>
            </div>
            <div class="scenario-content">
                <div class="visualization">
                    <canvas id="epidemicCanvas" width="450" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b35;"></div>
                            <span>Infected I(t)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>New Cases dI/dt</span>
                        </div>
                    </div>
                </div>
                <div class="explanation">
                    <div class="math-box">
                        <h4>Logistic Growth Model</h4>
                        <div class="formula">
                            <span class="equation-row" id="eq2a"></span>
                            <span class="equation-row" id="eq2b"></span>
                        </div>
                    </div>
                    <p class="insight">
                        The derivative <strong>dI/dt</strong> represents <em>new daily cases</em>. It's small when few are infected (nobody to spread it) AND when most are infected (nobody left to catch it). <strong>The peak of the derivative is the inflection point</strong>—where the curve changes from accelerating to decelerating. This is when interventions matter most.
                    </p>
                    <div class="controls">
                        <div class="slider-group">
                            <label>Transmission Rate (r)</label>
                            <input type="range" id="epiR" min="0.1" max="0.5" step="0.05" value="0.25">
                            <div class="value-display" id="epiRValue">r = 0.25</div>
                        </div>
                        <div class="slider-group">
                            <label>Population (K)</label>
                            <input type="range" id="epiK" min="500" max="2000" step="100" value="1000">
                            <div class="value-display" id="epiKValue">K = 1000</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Scenario 3: Distance and Velocity -->
        <section class="scenario">
            <div class="scenario-header">
                <div class="scenario-number">Scenario 03</div>
                <h2 class="scenario-title">The Accelerating Car</h2>
                <p class="scenario-question">How are position, velocity, and acceleration connected?</p>
            </div>
            <div class="scenario-content">
                <div class="visualization">
                    <canvas id="carCanvas" width="450" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffd700;"></div>
                            <span>Position x(t)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b35;"></div>
                            <span>Velocity dx/dt</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>Acceleration d²x/dt²</span>
                        </div>
                    </div>
                </div>
                <div class="explanation">
                    <div class="math-box">
                        <h4>Kinematics Chain</h4>
                        <div class="formula">
                            <span class="equation-row" id="eq3a"></span>
                            <span class="equation-row" id="eq3b"></span>
                        </div>
                    </div>
                    <p class="insight">
                        <strong>Differentiate once</strong>: position → velocity (how fast you're moving).<br>
                        <strong>Differentiate twice</strong>: position → acceleration (how fast velocity is changing).<br>
                        <strong>Integrate backward</strong>: the <em>area under the velocity curve</em> equals distance traveled. The area under acceleration equals change in velocity. Watch how the car animation syncs with all three curves!
                    </p>
                    <div class="controls">
                        <div class="slider-group">
                            <label>Acceleration (m/s²)</label>
                            <input type="range" id="carA" min="0.5" max="3" step="0.25" value="1.5">
                            <div class="value-display" id="carAValue">a = 1.5 m/s²</div>
                        </div>
                        <button id="carReset">Reset Animation</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Scenario 4: Optimization -->
        <section class="scenario">
            <div class="scenario-header">
                <div class="scenario-number">Scenario 04</div>
                <h2 class="scenario-title">The Optimal Box</h2>
                <p class="scenario-question">Given a fixed amount of material, what dimensions maximize volume?</p>
            </div>
            <div class="scenario-content">
                <div class="visualization">
                    <canvas id="boxCanvas" width="450" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b35;"></div>
                            <span>Volume V(x)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>dV/dx = 0 (optimal)</span>
                        </div>
                    </div>
                </div>
                <div class="explanation">
                    <div class="math-box">
                        <h4>Optimization via Derivatives</h4>
                        <div class="formula">
                            <span class="equation-row" id="eq4a"></span>
                            <span class="equation-row" id="eq4b"></span>
                        </div>
                    </div>
                    <p class="insight">
                        We're cutting squares of size <em>x</em> from each corner of cardboard, then folding up the sides. Too small an <em>x</em>? Shallow box. Too large? Tiny base.<br><br>
                        <strong>The derivative equals zero at the maximum</strong>—where the slope is flat. The second derivative tells us if it's truly a maximum (negative) or minimum (positive). Drag to find the sweet spot!
                    </p>
                    <div class="controls">
                        <div class="slider-group">
                            <label>Cut Size x (cm)</label>
                            <input type="range" id="boxX" min="0.5" max="6" step="0.1" value="2">
                            <div class="value-display" id="boxXValue">x = 2.0 cm</div>
                        </div>
                        <div class="slider-group">
                            <label>Cardboard Length (cm)</label>
                            <input type="range" id="boxL" min="20" max="40" step="2" value="30">
                            <div class="value-display" id="boxLValue">L = 30 cm</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>Calculus is the mathematics of <em>change</em>—derivatives measure rates, integrals accumulate totals.<br>
        Every smooth curve in nature speaks the language of calculus.</p>
    </footer>

    <script>
        // ==================== RESPONSIVE CANVAS SETUP ====================
        const BASE_WIDTH = 450;
        const BASE_HEIGHT = 300;
        const ASPECT_RATIO = BASE_HEIGHT / BASE_WIDTH;

        function getCanvasSize() {
            const containerWidth = Math.min(window.innerWidth - 40, 450);
            const width = Math.max(280, containerWidth);
            const height = width * ASPECT_RATIO;
            return { width, height };
        }

        function resizeAllCanvases() {
            const { width, height } = getCanvasSize();
            const canvases = [
                document.getElementById('coffeeCanvas'),
                document.getElementById('epidemicCanvas'),
                document.getElementById('carCanvas'),
                document.getElementById('boxCanvas')
            ];
            
            canvases.forEach(canvas => {
                if (canvas) {
                    // Set actual canvas resolution
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    
                    // Set display size
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    
                    // Scale context for retina displays
                    const ctx = canvas.getContext('2d');
                    ctx.scale(dpr, dpr);
                }
            });

            // Store display dimensions for drawing functions
            window.canvasDisplayWidth = width;
            window.canvasDisplayHeight = height;
        }

        // Utility functions
        function drawAxes(ctx, width, height, padding, xLabel, yLabel) {
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            ctx.fillStyle = '#8a8a95';
            const fontSize = width < 350 ? 9 : 11;
            ctx.font = `${fontSize}px JetBrains Mono`;
            ctx.fillText(xLabel, width - padding - 20, height - padding + 18);
            ctx.save();
            ctx.translate(padding - 8, padding + 20);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
        }

        function drawGrid(ctx, width, height, padding) {
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            const cols = 8, rows = 6;
            const w = (width - 2 * padding) / cols;
            const h = (height - 2 * padding) / rows;

            for (let i = 1; i < cols; i++) {
                ctx.beginPath();
                ctx.moveTo(padding + i * w, padding);
                ctx.lineTo(padding + i * w, height - padding);
                ctx.stroke();
            }
            for (let i = 1; i < rows; i++) {
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * h);
                ctx.lineTo(width - padding, padding + i * h);
                ctx.stroke();
            }
        }

        // ==================== SCENARIO 1: COFFEE ====================
        const coffeeCanvas = document.getElementById('coffeeCanvas');
        const coffeeCtx = coffeeCanvas.getContext('2d');
        const coffeeK = document.getElementById('coffeeK');
        const coffeeT0 = document.getElementById('coffeeT0');

        function drawCoffee() {
            const ctx = coffeeCtx;
            const width = window.canvasDisplayWidth || BASE_WIDTH;
            const height = window.canvasDisplayHeight || BASE_HEIGHT;
            const padding = width < 350 ? 35 : 50;

            ctx.clearRect(0, 0, width * 2, height * 2);
            drawGrid(ctx, width, height, padding);
            drawAxes(ctx, width, height, padding, 'time', 'temp');

            const k = parseFloat(coffeeK.value);
            const T0 = parseFloat(coffeeT0.value);
            const Troom = 22;
            const maxTime = 60;

            document.getElementById('coffeeKValue').textContent = `k = ${k.toFixed(2)}`;
            document.getElementById('coffeeT0Value').textContent = `T₀ = ${T0}°C`;

            // Fixed temperature scale (20°C to 100°C)
            const Tmin = 20;
            const Tmax = 100;
            const tempRange = Tmax - Tmin;

            // Temperature curve
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * maxTime;
                const T = Troom + (T0 - Troom) * Math.exp(-k * t);
                const x = padding + (i / 200) * (width - 2 * padding);
                const y = height - padding - ((T - Tmin) / tempRange) * (height - 2 * padding);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Derivative curve (rate of cooling) - scale based on max possible rate
            ctx.beginPath();
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            const maxPossibleRate = 0.15 * (100 - Troom); // max k * max temp difference
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * maxTime;
                const rate = -k * (T0 - Troom) * Math.exp(-k * t);
                const x = padding + (i / 200) * (width - 2 * padding);
                const y = height - padding - (-rate / maxPossibleRate) * (height - 2 * padding) * 0.6;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Room temperature line
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const roomY = height - padding - ((Troom - Tmin) / tempRange) * (height - 2 * padding);
            ctx.moveTo(padding, roomY);
            ctx.lineTo(width - padding, roomY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#8a8a95';
            ctx.font = '10px JetBrains Mono';
            ctx.fillText(`Room: ${Troom}°C`, width - padding - 70, roomY - 5);

            // Y-axis temperature labels
            ctx.fillStyle = '#8a8a95';
            ctx.font = '9px JetBrains Mono';
            ctx.fillText('100°C', padding - 40, padding + 5);
            ctx.fillText('60°C', padding - 35, padding + (height - 2 * padding) / 2);
            ctx.fillText('20°C', padding - 35, height - padding + 5);
        }

        coffeeK.addEventListener('input', drawCoffee);
        coffeeT0.addEventListener('input', drawCoffee);
        drawCoffee();

        // ==================== SCENARIO 2: EPIDEMIC ====================
        const epidemicCanvas = document.getElementById('epidemicCanvas');
        const epidemicCtx = epidemicCanvas.getContext('2d');
        const epiR = document.getElementById('epiR');
        const epiK = document.getElementById('epiK');

        function drawEpidemic() {
            const ctx = epidemicCtx;
            const width = window.canvasDisplayWidth || BASE_WIDTH;
            const height = window.canvasDisplayHeight || BASE_HEIGHT;
            const padding = width < 350 ? 35 : 50;

            ctx.clearRect(0, 0, width * 2, height * 2);
            drawGrid(ctx, width, height, padding);
            drawAxes(ctx, width, height, padding, 'days', 'cases');

            const r = parseFloat(epiR.value);
            const K = parseFloat(epiK.value);
            const I0 = 10;
            const maxDays = 60;

            document.getElementById('epiRValue').textContent = `r = ${r.toFixed(2)}`;
            document.getElementById('epiKValue').textContent = `K = ${K}`;

            // Infected curve
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            let prevI = I0;
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * maxDays;
                const I = K / (1 + ((K - I0) / I0) * Math.exp(-r * t));
                const x = padding + (i / 200) * (width - 2 * padding);
                const y = height - padding - (I / K) * (height - 2 * padding);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Derivative (new cases)
            ctx.beginPath();
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            const maxDeriv = r * K / 4; // max occurs at I = K/2
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * maxDays;
                const I = K / (1 + ((K - I0) / I0) * Math.exp(-r * t));
                const dIdt = r * I * (1 - I / K);
                const x = padding + (i / 200) * (width - 2 * padding);
                const y = height - padding - (dIdt / maxDeriv) * (height - 2 * padding) * 0.5;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Inflection point marker
            const tInflection = Math.log((K - I0) / I0) / r;
            if (tInflection > 0 && tInflection < maxDays) {
                const xInflection = padding + (tInflection / maxDays) * (width - 2 * padding);
                ctx.setLineDash([3, 3]);
                ctx.strokeStyle = 'rgba(255,215,0,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(xInflection, padding);
                ctx.lineTo(xInflection, height - padding);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#ffd700';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText('peak new cases', xInflection - 40, padding + 15);
            }
        }

        epiR.addEventListener('input', drawEpidemic);
        epiK.addEventListener('input', drawEpidemic);
        drawEpidemic();

        // ==================== SCENARIO 3: CAR ====================
        const carCanvas = document.getElementById('carCanvas');
        const carCtx = carCanvas.getContext('2d');
        const carA = document.getElementById('carA');
        const carReset = document.getElementById('carReset');
        let carTime = 0;
        let carAnimating = true;

        function drawCar() {
            const ctx = carCtx;
            const width = window.canvasDisplayWidth || BASE_WIDTH;
            const height = window.canvasDisplayHeight || BASE_HEIGHT;
            const padding = width < 350 ? 35 : 50;

            ctx.clearRect(0, 0, width * 2, height * 2);
            drawGrid(ctx, width, height, padding);
            drawAxes(ctx, width, height, padding, 'time', '');

            const a = parseFloat(carA.value);
            const maxTime = 6;
            const maxX = 0.5 * a * maxTime * maxTime;
            const maxV = a * maxTime;

            document.getElementById('carAValue').textContent = `a = ${a.toFixed(2)} m/s²`;

            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;

            // Position curve (yellow)
            ctx.beginPath();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * maxTime;
                const x = 0.5 * a * t * t;
                const px = padding + (i / 200) * plotWidth;
                const py = height - padding - (x / maxX) * plotHeight * 0.9;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Velocity curve (orange)
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * maxTime;
                const v = a * t;
                const px = padding + (i / 200) * plotWidth;
                const py = height - padding - (v / maxV) * plotHeight * 0.6;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Acceleration (constant - teal)
            ctx.beginPath();
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            const accY = height - padding - (a / 3) * plotHeight * 0.3;
            ctx.moveTo(padding, accY);
            ctx.lineTo(width - padding, accY);
            ctx.stroke();

            // Current time marker
            if (carTime <= maxTime) {
                const currentX = padding + (carTime / maxTime) * plotWidth;
                ctx.setLineDash([3, 3]);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(currentX, padding);
                ctx.lineTo(currentX, height - padding);
                ctx.stroke();
                ctx.setLineDash([]);

                // Animated car - scale for mobile
                const carPos = 0.5 * a * carTime * carTime;
                const carScreenX = padding + (carPos / maxX) * plotWidth * 0.9;
                const carScale = width < 350 ? 0.7 : 1;
                
                // Car body
                ctx.fillStyle = '#ff6b35';
                ctx.fillRect(carScreenX - 15 * carScale, height - padding + 8, 30 * carScale, 12 * carScale);
                ctx.fillRect(carScreenX - 10 * carScale, height - padding + 2, 20 * carScale, 8 * carScale);
                
                // Wheels
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(carScreenX - 8 * carScale, height - padding + 18 * carScale, 4 * carScale, 0, Math.PI * 2);
                ctx.arc(carScreenX + 8 * carScale, height - padding + 18 * carScale, 4 * carScale, 0, Math.PI * 2);
                ctx.fill();

                // Values display
                ctx.fillStyle = '#f5f5f0';
                const fontSize = width < 350 ? 9 : 11;
                ctx.font = `${fontSize}px JetBrains Mono`;
                const v = a * carTime;
                const x = 0.5 * a * carTime * carTime;
                const lineHeight = width < 350 ? 12 : 15;
                ctx.fillText(`t = ${carTime.toFixed(1)}s`, currentX + 8, padding + 15);
                ctx.fillText(`x = ${x.toFixed(1)}m`, currentX + 8, padding + 15 + lineHeight);
                ctx.fillText(`v = ${v.toFixed(1)}m/s`, currentX + 8, padding + 15 + lineHeight * 2);
            }
        }

        function animateCar() {
            if (carAnimating && carTime <= 6) {
                carTime += 0.03;
                drawCar();
            }
            if (carTime > 6) {
                carTime = 6;
                drawCar();
            }
            requestAnimationFrame(animateCar);
        }

        carA.addEventListener('input', () => {
            carTime = 0;
            drawCar();
        });

        carReset.addEventListener('click', () => {
            carTime = 0;
            carAnimating = true;
            drawCar();
        });

        animateCar();

        // ==================== SCENARIO 4: BOX OPTIMIZATION ====================
        const boxCanvas = document.getElementById('boxCanvas');
        const boxCtx = boxCanvas.getContext('2d');
        const boxX = document.getElementById('boxX');
        const boxL = document.getElementById('boxL');

        function drawBox() {
            const ctx = boxCtx;
            const width = window.canvasDisplayWidth || BASE_WIDTH;
            const height = window.canvasDisplayHeight || BASE_HEIGHT;
            const padding = width < 350 ? 35 : 50;

            ctx.clearRect(0, 0, width * 2, height * 2);
            drawGrid(ctx, width, height, padding);
            drawAxes(ctx, width, height, padding, 'cut size x', 'volume');

            const L = parseFloat(boxL.value);
            const W = L * 0.7; // Fixed aspect ratio
            const currentX = parseFloat(boxX.value);
            const maxCut = Math.min(L, W) / 2;

            document.getElementById('boxXValue').textContent = `x = ${currentX.toFixed(1)} cm`;
            document.getElementById('boxLValue').textContent = `L = ${L} cm`;

            // Calculate max volume for scaling
            let maxV = 0;
            let optimalX = 0;
            for (let x = 0.1; x < maxCut; x += 0.1) {
                const v = x * (L - 2 * x) * (W - 2 * x);
                if (v > maxV) {
                    maxV = v;
                    optimalX = x;
                }
            }

            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;

            // Volume curve
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 200; i++) {
                const x = (i / 200) * maxCut;
                const v = x * (L - 2 * x) * (W - 2 * x);
                if (v < 0) continue;
                const px = padding + (x / maxCut) * plotWidth;
                const py = height - padding - (v / maxV) * plotHeight * 0.9;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Optimal point marker
            const optPx = padding + (optimalX / maxCut) * plotWidth;
            const optPy = height - padding - 0.9 * plotHeight;
            
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(optPx, padding);
            ctx.lineTo(optPx, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#4ecdc4';
            ctx.beginPath();
            ctx.arc(optPx, optPy, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#4ecdc4';
            ctx.font = '10px JetBrains Mono';
            ctx.fillText(`optimal: x ≈ ${optimalX.toFixed(1)}`, optPx + 10, optPy - 10);
            ctx.fillText('dV/dx = 0', optPx + 10, optPy + 5);

            // Current selection marker
            const currentV = currentX * (L - 2 * currentX) * (W - 2 * currentX);
            if (currentV > 0) {
                const curPx = padding + (currentX / maxCut) * plotWidth;
                const curPy = height - padding - (currentV / maxV) * plotHeight * 0.9;

                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(curPx, curPy, 8, 0, Math.PI * 2);
                ctx.fill();

                // 3D box preview
                // Scale factor for responsive box preview
                const boxScale = width < 350 ? 0.7 : 1;
                const boxBaseW = 60 * boxScale;
                const boxBaseH = 42 * boxScale;
                const boxDepth = Math.min(30 * boxScale, currentX * 3 * boxScale);
                const boxCenterX = width - (width < 350 ? 55 : 80);
                const boxCenterY = height - (width < 350 ? 55 : 80);
                const isoOffset = 15 * boxScale;

                // Isometric box
                const scaledW = boxBaseW * ((L - 2 * currentX) / L);
                const scaledH = boxBaseH * ((W - 2 * currentX) / W);

                // Front face
                ctx.fillStyle = 'rgba(255,107,53,0.6)';
                ctx.beginPath();
                ctx.moveTo(boxCenterX - scaledW / 2, boxCenterY);
                ctx.lineTo(boxCenterX + scaledW / 2, boxCenterY);
                ctx.lineTo(boxCenterX + scaledW / 2, boxCenterY - boxDepth);
                ctx.lineTo(boxCenterX - scaledW / 2, boxCenterY - boxDepth);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Top face
                ctx.fillStyle = 'rgba(255,107,53,0.3)';
                ctx.beginPath();
                ctx.moveTo(boxCenterX - scaledW / 2, boxCenterY - boxDepth);
                ctx.lineTo(boxCenterX + scaledW / 2, boxCenterY - boxDepth);
                ctx.lineTo(boxCenterX + scaledW / 2 - isoOffset, boxCenterY - boxDepth - scaledH / 2);
                ctx.lineTo(boxCenterX - scaledW / 2 - isoOffset, boxCenterY - boxDepth - scaledH / 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Side face
                ctx.fillStyle = 'rgba(255,107,53,0.45)';
                ctx.beginPath();
                ctx.moveTo(boxCenterX - scaledW / 2, boxCenterY);
                ctx.lineTo(boxCenterX - scaledW / 2, boxCenterY - boxDepth);
                ctx.lineTo(boxCenterX - scaledW / 2 - isoOffset, boxCenterY - boxDepth - scaledH / 2);
                ctx.lineTo(boxCenterX - scaledW / 2 - isoOffset, boxCenterY - scaledH / 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#f5f5f0';
                const fontSize = width < 350 ? 9 : 11;
                ctx.font = `${fontSize}px JetBrains Mono`;
                ctx.fillText(`V = ${currentV.toFixed(0)} cm³`, boxCenterX - 35 * boxScale, boxCenterY + 18);
            }
        }

        boxX.addEventListener('input', drawBox);
        boxL.addEventListener('input', () => {
            const L = parseFloat(boxL.value);
            const W = L * 0.7;
            const maxCut = Math.min(L, W) / 2;
            boxX.max = maxCut - 0.5;
            if (parseFloat(boxX.value) > maxCut - 0.5) {
                boxX.value = maxCut - 0.5;
            }
            drawBox();
        });
        drawBox();

        // ==================== RENDER EQUATIONS WITH KATEX ====================
        function renderEquations() {
            // Scenario 1: Coffee Cooling
            katex.render(String.raw`\frac{dT}{dt} = -k(T - T_{\text{room}})`, document.getElementById('eq1a'), {displayMode: false});
            katex.render(String.raw`T(t) = T_{\text{room}} + (T_0 - T_{\text{room}})e^{-kt}`, document.getElementById('eq1b'), {displayMode: false});

            // Scenario 2: Epidemic
            katex.render(String.raw`\frac{dI}{dt} = rI\left(1 - \frac{I}{K}\right)`, document.getElementById('eq2a'), {displayMode: false});
            katex.render(String.raw`I(t) = \frac{K}{1 + \left(\frac{K - I_0}{I_0}\right)e^{-rt}}`, document.getElementById('eq2b'), {displayMode: false});

            // Scenario 3: Car Kinematics
            katex.render(String.raw`x(t) \xrightarrow{\frac{d}{dt}} v(t) \xrightarrow{\frac{d}{dt}} a(t)`, document.getElementById('eq3a'), {displayMode: false});
            katex.render(String.raw`x = \tfrac{1}{2}at^2 \quad\Rightarrow\quad v = at \quad\Rightarrow\quad a = \text{const}`, document.getElementById('eq3b'), {displayMode: false});

            // Scenario 4: Box Optimization
            katex.render(String.raw`V(x) = x(L - 2x)(W - 2x)`, document.getElementById('eq4a'), {displayMode: false});
            katex.render(String.raw`\text{Set } \frac{dV}{dx} = 0 \text{ to find maximum}`, document.getElementById('eq4b'), {displayMode: false});
        }

        renderEquations();

        // ==================== INITIALIZATION & RESIZE HANDLING ====================
        function redrawAll() {
            resizeAllCanvases();
            drawCoffee();
            drawEpidemic();
            drawCar();
            drawBox();
        }

        // Initial setup
        resizeAllCanvases();
        drawCoffee();
        drawEpidemic();
        drawBox();
        // Car animation starts automatically

        // Handle window resize with debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(redrawAll, 150);
        });

        // Handle orientation change on mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(redrawAll, 100);
        });
    </script>
</body>
</html>
